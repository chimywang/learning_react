'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path2 = require('path');

var _path3 = _interopRequireDefault(_path2);

var _module = require('module');

var _module2 = _interopRequireDefault(_module);

var _log = require('./tools/log');

var _log2 = _interopRequireDefault(_log);

var _helpers = require('./helpers');

var _serializeJavascript = require('./tools/serialize-javascript');

var _serializeJavascript2 = _interopRequireDefault(_serializeJavascript);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Hacking too much time

// Based on Node.js Module class sources:
// https://github.com/nodejs/node/blob/master/lib/module.js

var require_hacker = {
	preceding_path_resolvers: [],
	path_resolvers: [],

	global_hook_resolved_modules: {},

	global_hooks_enabled: true,

	occupied_file_extensions: new _set2.default(),

	// logging
	log: new _log2.default('require-hacker', { debug: false }), // this.options.debug

	// installs a require() path resolver 
	//
	// resolve - a function which takes two parameters:
	//
	//             the path to be resolved
	//             the module in which the require() call was originated
	//
	//           must return either a new path to the require()d module
	//           or it can return nothing to fall back to the original require()d module path
	//
	// returns an object with an .unmount() method
	//
	resolver: function resolver(resolve) {
		validate.resolve(resolve);

		var resolver = function resolver(path, module) {
			// resolve the path for this require() call
			var resolved_path = resolve(path, module);

			// if no path was resolved - do nothing
			if (!(0, _helpers.exists)(resolved_path)) {
				return;
			}

			// return the path to be require()d 
			return resolved_path;
		};

		require_hacker.preceding_path_resolvers.push(resolver);

		var result = {
			unmount: function unmount() {
				// javascript arrays still have no .remove() method in the XXI-st century
				require_hacker.preceding_path_resolvers = require_hacker.preceding_path_resolvers.filter(function (x) {
					return x !== resolver;
				});
			}
		};

		return result;
	},


	// installs a global require() hook for all paths 
	//
	// (if these paths are certain to exist in the filesystem
	//  and if you need only a specific file extension
	//  then use the .hook(extension, resolve) method instead)
	//
	// id - a meaningful textual identifier
	//
	// resolve - a function which takes two parameters:
	//
	//             the path to be resolved
	//             the module in which the require() call was originated
	//
	//           must return either a javascript CommonJS module source code
	//           (i.e. "module.exports = ...", etc)
	//           or it can return nothing to fall back to the original Node.js loader
	//
	// returns an object with an .unmount() method
	//
	// options:
	//
	//   precede_node_loader:
	//     
	//     true  - this require() hook will intercept all require() calls
	//             before they go into the original Node.js loader
	//    
	//     false - this require() hook will only intercept those require() calls
	//             which failed to be resolved by the original Node.js loader
	//
	//     default value: true
	//
	global_hook: function global_hook(id, resolve) {
		var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

		validate.global_hook(id, resolve);

		var resolver = function resolver(path, module) {
			// log.debug(`Global require() hook "${id}" fired`)

			// get CommonJS module source code for this require() call
			var source = resolve(path, module);

			// if no CommonJS module source code returned - skip this require() hook
			if (!(0, _helpers.exists)(source)) {
				return;
			}

			// CommonJS module source code returned, 
			// so put it into a hash for a corresponding key

			var resolved_path = path + '.' + id;

			// flush require() cache
			delete require.cache[resolved_path];

			// put the CommonJS module source code into the hash
			require_hacker.global_hook_resolved_modules[resolved_path] = source;

			// return the path to be require()d 
			// in order to get the CommonJS module source code
			return resolved_path;
		};

		if (options.precede_node_loader === false) {
			require_hacker.path_resolvers.push(resolver);
		} else {
			require_hacker.preceding_path_resolvers.push(resolver);
		}

		var hook = this.hook(id, function (path) {
			var source = require_hacker.global_hook_resolved_modules[path];
			delete require_hacker.global_hook_resolved_modules[path];
			return source;
		});

		var result = {
			unmount: function unmount() {
				// javascript arrays still have no .remove() method in the XXI-st century
				require_hacker.preceding_path_resolvers = require_hacker.preceding_path_resolvers.filter(function (x) {
					return x !== resolver;
				});
				require_hacker.path_resolvers = require_hacker.path_resolvers.filter(function (x) {
					return x !== resolver;
				});
				hook.unmount();
			}
		};

		return result;
	},


	// installs a require() hook for the extension
	//
	// extension - a file extension to hook into require()s of
	//             (examples: 'css', 'jpg', 'js')
	//
	// resolve   - a function that takes two parameters: 
	//
	//               the path requested in the require() call 
	//               the module in which the require() call was originated
	//
	//             must return either a javascript CommonJS module source code
	//             (i.e. "module.exports = ...", etc)
	//             or it can return nothing to fall back to the original Node.js loader
	//
	hook: function hook(extension, resolve) {
		var _this = this;

		this.log.debug('Hooking into *.' + extension + ' files loading');

		// validation
		validate.extension(extension);
		validate.resolve(resolve);

		// occupy file extension
		this.occupied_file_extensions.add(extension);

		// dotted extension
		var dot_extension = '.' + extension;

		// keep original extension loader
		var original_loader = _module2.default._extensions[dot_extension];

		// display a warning in case of extension loader override
		if (original_loader) {
			// output a debug message in case of extension loader override,
			// not a warning, so that it doesn't scare people
			this.log.debug('-----------------------------------------------');
			this.log.debug('Overriding an already existing require() hook ');
			this.log.debug('for file extension ' + dot_extension);
			this.log.debug('-----------------------------------------------');
		}

		// the list of cached modules
		var cached_modules = new _set2.default();

		// Node.js inner API check
		/* istanbul ignore if */
		if (!_module2.default._extensions) {
			throw new Error('Incompatilbe Node.js version detected: "Module._extensions" array is missing. File an issue on GitHub.');
		}

		// set new loader for this extension
		_module2.default._extensions[dot_extension] = function (module, filename) {
			_this.log.debug('require() hook fired for ' + filename);

			// var source = fs.readFileSync(filename, 'utf8')
			var source = resolve(filename, module);

			if (!(0, _helpers.exists)(source)) {
				_this.log.debug('Fallback to original loader');

				// this message would appear if there was no loader 
				// for the extension of the filename
				if (_path3.default.extname(filename) !== dot_extension) {
					_this.log.info('Trying to load "' + _path3.default.basename(filename) + '" as a "*' + dot_extension + '"');
				}

				// load the file with the original loader
				return (original_loader || _module2.default._extensions['.js'])(module, filename);
			}

			// add this file path to the list of cached modules
			cached_modules.add(filename);

			// Node.js inner API check
			/* istanbul ignore if */
			if (!module._compile) {
				throw new Error('Incompatilbe Node.js version detected: "Module.prototype._compile" function is missing. File an issue on GitHub.');
			}

			// compile javascript module from its source
			// https://github.com/nodejs/node/blob/master/lib/module.js#L379
			module._compile(source, filename);
		};

		var result = {
			// uninstall the hook
			unmount: function unmount() {
				// clear require() cache for this file extension
				var _iteratorNormalCompletion = true;
				var _didIteratorError = false;
				var _iteratorError = undefined;

				try {
					for (var _iterator = (0, _getIterator3.default)(cached_modules), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
						var _path = _step.value;

						delete require.cache[_path];
					}

					// mount the original loader for this file extension
				} catch (err) {
					_didIteratorError = true;
					_iteratorError = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion && _iterator.return) {
							_iterator.return();
						}
					} finally {
						if (_didIteratorError) {
							throw _iteratorError;
						}
					}
				}

				_module2.default._extensions[dot_extension] = original_loader;

				// free file extension
				_this.occupied_file_extensions.delete(extension);
			}
		};

		return result;
	},


	// returns a CommonJS modules source.
	to_javascript_module_source: function to_javascript_module_source(anything) {
		// if the asset source wasn't found - return an empty CommonJS module
		if (!(0, _helpers.exists)(anything)) {
			return 'module.exports = undefined';
		}

		// if it's already a common js module source
		if (typeof anything === 'string' && is_a_module_declaration(anything)) {
			return anything;
		}

		// generate javascript module source code based on the `source` variable
		return 'module.exports = ' + (0, _serializeJavascript2.default)(anything);
	},


	// resolves a requireable `path` to a real filesystem path relative to the `module`
	// (resolves `npm link`, etc)
	resolve: function resolve(path_to_resolve, module) {
		// Module._resolveFilename existence check is perfomed outside of this method
		try {
			require_hacker.global_hooks_enabled = false;
			return original_resolveFilename(path_to_resolve, module);
		} finally {
			require_hacker.global_hooks_enabled = true;
		}
	}
};

// validation
var validate = {
	extension: function extension(_extension) {
		// if (typeof extension !== 'string')
		// {
		// 	throw new Error(`Expected string extension. Got ${extension}`)
		// }

		if (_path3.default.extname('test.' + _extension) !== '.' + _extension) {
			throw new Error('Invalid file extension "' + _extension + '"');
		}

		// check if the file extension is already occupied
		if (require_hacker.occupied_file_extensions.has(_extension)) {
			throw new Error('File extension "' + _extension + '" is already occupied by require-hacker');
		}
	},
	resolve: function resolve(_resolve) {
		if (typeof _resolve !== 'function') {
			throw new Error('Resolve should be a function. Got "' + _resolve + '"');
		}
	},
	global_hook: function global_hook(id, resolver) {
		if (!id) {
			throw new Error('You must specify global hook id');
		}

		if (_path3.default.extname('test.' + id) !== '.' + id) {
			throw new Error('Invalid global hook id "' + id + '". Expected a valid file extension.');
		}

		// check if the file extension is already occupied
		if (require_hacker.occupied_file_extensions.has(id)) {
			throw new Error('File extension "' + id + '" is already occupied by require-hacker');
		}

		validate.resolve(resolver);
	}
};

// Node.js inner API check
/* istanbul ignore if */
if (!_module2.default._resolveFilename) {
	throw new Error('Incompatilbe Node.js version detected: "Module._resolveFilename" function is missing. File an issue on GitHub.');
}

// Node.js inner API check
/* istanbul ignore if */
if (!_module2.default._findPath) {
	throw new Error('Incompatilbe Node.js version detected: "Module._findPath" function is missing. File an issue on GitHub.');
}

// the module in which the require() call originated
var require_caller = void 0;

// instrument Module._resolveFilename
// https://github.com/nodejs/node/blob/master/lib/module.js#L322
//
// `arguments` would conflict with Babel, therefore `...parameters`
//
// const native_module = require('native_module')
var original_resolveFilename = _module2.default._resolveFilename;
_module2.default._resolveFilename = function () {
	for (var _len = arguments.length, parameters = Array(_len), _key = 0; _key < _len; _key++) {
		parameters[_key] = arguments[_key];
	}

	var request = parameters[0];
	var parent = parameters[1];

	// take note of the require() caller
	// (the module in which this require() call originated)
	require_caller = parent;

	return original_resolveFilename.apply(this, parameters);
};

// instrument Module._findPath
// https://github.com/nodejs/node/blob/master/lib/module.js#L335-L341
//
// `arguments` would conflict with Babel, therefore `...parameters`
//
var original_findPath = _module2.default._findPath;
_module2.default._findPath = function () {
	for (var _len2 = arguments.length, parameters = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		parameters[_key2] = arguments[_key2];
	}

	var request = parameters[0];
	// const paths = parameters[1]

	// preceeding resolvers
	if (require_hacker.global_hooks_enabled) {
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = (0, _getIterator3.default)(require_hacker.preceding_path_resolvers), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var resolver = _step2.value;

				var resolved_path = resolver(request, require_caller);
				if ((0, _helpers.exists)(resolved_path)) {
					return resolved_path;
				}
			}
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}
	}

	// original Node.js loader
	var filename = original_findPath.apply(undefined, parameters);
	if (filename !== false) {
		return filename;
	}

	// rest resolvers
	if (require_hacker.global_hooks_enabled) {
		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = (0, _getIterator3.default)(require_hacker.path_resolvers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _resolver = _step3.value;

				var resolved = _resolver.resolve(request, require_caller);
				if ((0, _helpers.exists)(resolved)) {
					return resolved;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}
	}

	return false;
};

// detect if it is a CommonJS module declaration
function is_a_module_declaration(text) {
	return text.indexOf('module.exports = ') === 0 || /\s+module\.exports = .+/.test(text);
}

exports.default = require_hacker;
module.exports = exports['default'];
//# sourceMappingURL=require hacker.js.map